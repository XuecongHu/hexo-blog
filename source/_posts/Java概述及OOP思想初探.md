---
title: Java概述及OOP思想初探
date: 2017-08-27 22:38:14
tags: Java
---
（注： 本文是我阅读《Java编程思想》前言、绪论、第一和第二章以及《Java核心技术卷1》第一章后，对于本人比较重要的摘抄与个人思考）

上帝赋予人类说话的能力，而言语又创造了思想，思想是对宇宙的量度——Promethus Unbound, Shelly

<!--more-->

Java已经不仅仅是一门编程语言了。
Java设计目标和特性
作为一个平台，Java拥有庞大的类库和可重用的代码，提供了安全、系统可移植和垃圾回收的机制，以及众多的良好特性：
Simple
cleaned-up version of C++ syntax: 去除了头文件、指针语法及相关运算、结构体、运算符重载、虚拟类等。同时为了让Java更容易理解，语法上也和C++相似
small: 基本解释器和类支持大约40KB
Object-Oriented
focus on data(=objects) an on the interfaces to that object
Java对比C++有着更简洁的接口，仅支持单一继承，比C++有更良好的反省机制
Distributed
有大量的库支持TCP/IP协议，访问由网络到达的对象就像访问本地文件系统中的对象一样简单
Robust
Java编译器能够发现很多在别的语言只能在运行时才能发现的错误
Java的指针模型能够消灭重写和污染内存数据的情况
Secure
不信任的代码会在沙盒环境中执行，而不影响宿主系统。不管代码从哪来，都无法逃离沙盒
Architecture-Neutral
编译器会生成平台独立的对象文件格式，即与特定计算机系统架构无关的字节码指令
虚拟机可以翻译执行最频繁的字节码序列为机器码(just-in-time编译）
虚拟机可以检查字节码序列的行为，使得更安全
Portable
没有因具体实现而不同的规格：基本数据类型的长度及其上的算术运算都是固定的
Interpreted
Java解释器可以在任何一台机器上直接执行Java字节码
Linking is a more incremental and lightweight process（Linking: process of taking  a class or interface and combining it into the run-time state of the JVM）
High-Performance
just-in-time compiler: optimize frequently executed code for speed
elimination (inlining) of function calls: use inlining based upon the currently loaded collection of classes
Multithreaded
first mainstream language to support concurrent programming
concurrent programming to make sure the user interface didn't freeze
Java make it manageable
Dynamic
designed to adapt to an evolving environment.
libraries can freely add new methods and instance variables without any effects on their clients, eg, Java applets( code downloaded from the Internet to run in the browser).
因此，Java备受广大程序员欢迎。
但Java并不仅仅是这些良好特性的集合，如果单独看这些特性，是毫无意义的。Java实际上提供了一种表达概念的方式，和人类的任何语言一样。我们看待Java时，要从语言设计的角度来出发考虑问题，而不能只从编码的角度，要思考编程问题为什么会成为问题以及Java采取了什么样的解决方案。

可以认为，Java从面向对象的方式，更好地解决了编程复杂度的问题。
编程是一项管理复杂度的工作，这里的复杂度包括了待解决问题的复杂度和要用来解决该问题的机器的复杂度。而程序设计项目的成功关键则在于复杂度的管理。
在Java之前，很多程序设计语言都没有把核心目标放在克服开发和维护程序的复杂度上。C++为了向后兼容C以及效率问题导致了复杂度的问题没有处理好。VB为了与Basic绑定一起，导致可扩展性较弱。而Java的主要设计目标之一就是"reducing the time and difficulty of producing robust code"。再加上它解决了复杂度中的一些大问题：跨平台、动态语言和安全，所以Java备受程序员的欢迎，极大地提高了开发健壮程序的效率，使得编写程序更加简单。而这很大程度上都归功于面向对象，即OOP。
OOP导论
所有编程语言都提供了抽象机制，解决问题的复杂性直接取决于抽象的类型（类型是指抽象的是什么）和质量。例如汇编是对底层机器的抽象，命令式语言是对汇编的抽象。而这些命令式语言通常会要求程序员基于计算机系统的结构去想问题，而不是基于要解决的问题本身。因此在程序设计时，必须要在待解决问题的建模与机器建模中间建立联系，使得程序设计非常费时费力，编写出的代码也难以理解。
另外一种对机器建模的方式只针对待解问题建模。LISP和APL都只考虑世界中的某些特定视图。LISP对应的所有问题都是列表，APL对应的所有问题都是算法形式。这样的建模离开了特定的领域就不适用。
而OOP是一种非常通用的，适用于任何问题的建模方式。首先OOP提供了某种工具来表示问题空间中的元素，而且还不受问题类型的限制。OOP将问题空间中的元素及其在解空间中的表示称为“对象”。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。但是对象依然与计算机有联系的：每个对象都像一台微型计算机，有状态及其操作。
总结起来，OOP具有5个基本特性：
万物皆对象
程序是对象的集合，通过发送消息来告知彼此所要做的
每个对象都有自己的由其他对象所构成的存储
每个对象都有类型
某一特定类型的所有对象都可以接受同样的消息
每个对象有一个接口
程序执行期间具有不同的状态而其他方面都相似的对象会被分配到对象的类中。
创建抽象数据类型（类）是OOP的基本概念之一，程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。编程系统会像对待内置类型一样地照管它们和进行类型检查。
OOP的挑战之一就是在问题空间的元素和解空间的对象之间创建一对一的映射。
每个对象所能完成的请求由对象的接口定义，决定接口的便是类型。
为什么编程需要类型？为什么OOP需要可以自定义的类型？

每个对象都提供服务
在试图开发和理解程序的时候，可以将对象想象为服务的提供者。程序设计的一个主要目标就是创建（或在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。用该思维方式有助于在设计的过程，从问题抽取对象出来。
另外，把对象看做是服务提供者还有一个附带的好处就是高内聚。一个对象不能塞满了过多的功能。

被隐藏的具体实现（封装）
在面向对象中，会将程序开发人员分为类创建者和客户端程序员。类只向客户端暴露必需的部分，而隐藏其他部分，意味着这些部分类创建者可以任意修改，而不担心对客户端程序员造成影响，被隐藏的部分往往是程序脆弱的部分，从而减少bug。
而为了达到这个目的，就必须存在访问控制。访问控制使得客户端无法触及不该接触的部分，允许类创建者任意修改隐藏的部分而不担心对客户端造成影响。

复用具体实现
代码复用是面向对象最大的优处之一。
最简单的复用就是使用某个类的一个对象。
使用现有的类合成新的类，称为组合，是一种”has-a”的关系。
组合是动态发生的则是聚合。
建立新类时，应该首先考虑组合，因为更加简单灵活。

继承
创建一个类后，一个新类与之具有相似的功能，还得重新创建一个类的麻烦，可以通过继承来解决。
有了继承之后，类型不仅仅是对一个对象集合的约束，还代表了类型与类型之间的关系。
继承复制了基类的接口，意味着所有发送给基类对象的消息同时也可以发送给到处类，导出类和基类具有相同的类型。通过继承而产生了类型等价性。
只有两种方法使得导出类和基类有差异：覆盖(overriding)和添加新方法。

Is-a vs lis-like-a
Is-a表示导出类只覆盖了基类的方法，而不添加新方法，两个类具有完全相同的接口，完全可以用一个导出类来替代基类对象，是处理继承的理想方式，称之为里氏替代原则。如一个圆形就是一个几何形状。
is-like-a表示导出类添加了新的方法，因为导出类除了有基类的接口，还有扩展的新接口，两个类并非完全相同，导出类拥有基类无法访问的新添加接口。

多态
在编写继承的代码时候，会将导出类的对象当做基类对象来处理，编写出不依赖于特定类型的代码。这样的代码不受新添加类型的影响，而添加新类型来扩展程序是最理想的处理新情况的办法。通过导出完全新的子类型而轻松扩展设计，能够极大地改善设计和降低软件维护的代价。
但是把导出类型对象当做是基类对象处理时会存在问题，即编译器在编译时不可能知道具体执行哪个代码。

解决的关键就是面向对象程序设计的最重要关键：编译器不可能产生传统意义上的函数调用（会引起了前期绑定），而使用了后期绑定的概念。
后期绑定： 当向对象发送消息的时候，被调用的代码直到运行时才能确定，编译器确保被调用方法的存在，并对调用参数和返回值做类型检查（强类型），但是并不知道具体要调用的确切代码

前期绑定
后期绑定
编译器产生一个具体函数名字的调用，运行时将这个调用解析到要被执行代码的绝对地址
Java用一小段特殊的代码来替代绝对地址调用，使用在对象中存储的信息来计算方法体的地址。根据这一小段代码，每一个对象都有不同的行为表现。

Java默认是后期绑定，C++是使用virtual关键字来实现，必须明确地声明哪些方法具备。

把导出类看作是它的基类的过程称为向上转型（upcasting）。
一个面向对象程序必然会在某个地方包含upcasting，这正是从确切类型解放的关键。
例如：
void doSomething(Shape shape) {
	shape.erase();
	// ...
	shape.draw();
}

这段代码要表达的意思仅仅是你是一个Shape，可以erase和draw，不管是具体什么类型。
正是因为多态，才使得可以执行正确的方法。

单根继承结构
保证所有对象都具有某些功能，在系统中对每个对象执行某些基本操作，所有对象都很容易地在堆上创建，参数传递也得到了极大的简化。
单根使得垃圾回收期的实现变得容易很多，所有对象都保证具有其类型信息，不会因无法确定对象的类型而陷入僵局，对于系统级操作（如异常处理）非常重要。

容器
在解决特定问题时不知道需要多少个对象，或者要存活多久，这类信息只有在运行时才能知道，解决方案就是创建容器对象，在任何需要时都可以扩充自己容纳置于其中的所有东西。

参数化类型（泛型）
Java SE5之前，容器存储的对象只有通用类型Object，单根继承结构意味着可以存储Object的容器可以存储任何东西，使得容器很容易被复用。要使用容器只需要把对象引用放进去，需要用的时候取出来即可。但是有问题在于容器存储的是Object类型，对象放进容器的时候upcasting为Object对象，而取出来的时候，获取了是对Object对象的引用，而不是原来对象的引用，丢失了“身份”。而要解决这个问题，就必须向下转型，从基类转化为导出类。
向上转型无疑是安全的，但向下转型是不安全的，除非知道具体类型。如果向下转型为错误的类型，就会发生运行时的异常。
为了减少容器中向下转型可能发生的错误，使用参数化类型机制，创建一个知道要保存对象类型的容器。参数化类型就是一个编译器可以自动定制作用于特定类型上的类。

对象的创建和生命期
每个对象为了生存都需要资源，尤其是内存，当对象不再被需要的时候，必须被处理掉，使资源可以被释放和重用。所以对象的销毁就变得十分重要。
但是怎么样才能知道何时销毁这些对象？处理完某个对象之后，系统中其他部分可能还会在处理。
对象的数据位于什么地方？怎样控制对象的生命周期？
C++认为效率控制最重要，为了追求最大的执行速度，对象的存储空间和生命周期在编写程序时确定，将对象置于堆栈或静态存储区域，将存储空间分配和释放置于优先考虑的位置，牺牲了灵活性，必须在编写时知道对象的确切数量、生命周期和类型。
另外一种方法是在被称为堆（heap）的内存池中动态地创建对象，直到运行才知道需要多少对象，生命周期如何以及具体的类型是什么。存储空间是在运行时被动态管理的，所以需要大量的时间在堆中分配存储空间，远远大于在堆栈中创建存储空间的时间（堆栈中创建存储和释放空间各需要一条汇编指令，分别对应将栈顶指针向下移动和将栈顶指针向上移动）。
对于在堆栈中创建对象的语言，编译器可以确定对象存活的时间，并且自动销毁。在堆上创建对象，编译器就会对它的生命周期一无所知。C++的销毁对象方式可能会带来因为未正确处理而导致内存泄漏的常见问题。

异常处理： 处理错误
异常是一个对象，从出错地点被”抛出“，并被专门设计用来处理特定类型错误的异常处理器”捕获“。
异常处理是与正常执行路径完全分离的并行路径，不会干扰正常的执行代码，使得代码编写变得简单，而且不能被忽略，保证一定会在某个地方得到处理，提供了一种从错误状况进行可靠恢复的路径，而不是只能退出程序，可以经常校正，恢复程序的执行，编写出更健壮的程序。
异常处理并不是面向对象的特征。

并发编程
彼此独立运行的部分称为线程，同一时刻运行多个线程称为并发。并发的最常见例子就是用户界面。
在语言级别，多线程的便利之一就是程序员不用再担心机器上有多个处理器还是只有一个处理器。程序在逻辑上被划分为线程，机器拥有多个处理器，程序不需要特殊调整也能执行得更快。

总结
过程型语言（需要通读数据定义和函数调用，建立中间表示形式）更加面向计算机而不是要解决的问题。
在OOP中，只看到两部分内容的含义：用来表示问题空间概念的对象以及发送给这些对象的用来表示在此空间内的行为的消息。
编写良好的Java程序通常比过程型程序要简单地多，而且也易于理解得多。

万物皆对象

用引用操作对象
每一种编程语言都有自己操纵内存元素的方式，可以直接操纵元素，还是基于某种特殊语法的间接表示（例如C/C++的指针）。
Java中一切都是对象，可采用单一固定的语法，但操纵的标识符实际上只是对象的一个引用。
Java中的引用更接近C++的引用而不是指针。
String s;

上面这段代码只创建了引用，而不是对象，如果向s发送消息，会返回错误，因为s没有与任何实际的对象关联。

必须由你创建所有对象
通过new操作符，与新的对象相关联：
String s = new String("asdf");

对象存储的地方：
寄存器。不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（C和C++允许向编译器建议寄存器的分配方式）。
堆栈（RAM区中）。堆栈指针向上下移动，可以申请或释放内存。Java系统必须知道存储在堆栈内所有项的确切生命周期，某些Java数据存储在该部分，特别是对象引用。
堆（RAM区中）。自动动态分配内存，Java所有对象都在此区域。代价是存储分配需要更多时间。
常量存储。直接存放在程序代码内部。
非RAM存储。数据完全存活于程序之外，与程序独立。两个基本例子就是流对象和持久化对象。流对象，对象转化为字节流，通常发送给另一台机器，持久化对象则是被存放在磁盘上，即使程序终止，仍可以保持自己的状态。Java提供了对轻量级持久化的支持，JDBC和Hibernate提供了更加复杂对在数据库中存储和读取对象信息的支持。

基本类型与数组
用New创建一个对象，特别是小的和简单的变量，往往不是很有效。 Java创建一个并非是引用的”自动“变量，直接存储”值“，置于堆栈中。
基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。
BigInteger可以表示任何精度的整数，BigDecimal则是表示任何精度的浮点数，用精度牺牲了速度。
在C和C++中使用数组是很危险的，因为C和C++的数组就是内存块。一个程序访问其自身内存块之外的数组，或者在数组初始化之前使用内存，都会产生难以预料的后果。
Java的其中一个主要目标是安全。确保数组会被初始化，而且不能在它的范围之外被访问，以每个数组上少量的内存开销以及运行时的下标检查为代价，换来的是安全性和效率的提高。
创建一个对象数组，就是创建一个引用数组，每个引用都会自动初始化为null值。创建基本数据类型的数组初始化全部都置零。

不需要销毁对象
作用域决定了在其定义的变量的可见性和生命周期，作用域内定义的变量只可作用域结束之前。
对象可以存活于作用域之外：
{
	String s = new String("a string");
} // End of Scope

引用变量s在作用域中已经消失了，但是s指向的对象还占据内存。只要你需要，new创建出来的对象就会一直保留下去。
但是对象一直在内存，万一塞满了内存要如何解决？Java的垃圾回收器监视用New创建的所有对象，辨别不会再被引用的对象，随后释放内存空间。

创建新的数据类型：类
类的基本数据类型成员会进行初始化，才会得到默认值，其他情况的变量都不会初始化。（PS: char的默认值是空字符'\u0000')
反转自己的Internet域名，来保证给一个类库生成不会与其他名字混淆的名字，解决名字冲突。

构建第一个Java程序
import关键字指示编译器准确导入一个包（类库）中的类，解决要使用特定名字类时定义不只一份的冲突
static意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起，即使从未创建某个类的任何对象，也可以调用其static方法或访问static域。
使用类名来引用static变量不仅强调了变量的static结构，在某些情况下为编译器优化提供了更好的机会。
static方法的一个重要用法就是在不创建任何对象的前提下可以调用它，对于定义main()方法很重要，是运行一个应用的入口。
